"""
Fidoo Expense Management API Driver

REST API driver for Fidoo expense management and card operations.

Key Features:
- Card transaction monitoring
- User management
- Expense tracking and reporting
- Travel and billing operations
- Batch card operations (load/unload)

Example:
    from fidoo import FidooDriver

    client = FidooDriver.from_env()
    try:
        users = client.list_objects()
        cards = client.read("card", limit=10)
    finally:
        client.close()

API Documentation: https://www.fidoo.com/expense-management/integrace/api
"""

import os
import logging
import time
import requests
from typing import List, Dict, Any, Optional, Iterator
from urllib.parse import urljoin
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

# Try package imports first, fallback to standalone
try:
    from .base import BaseDriver, DriverCapabilities, PaginationStyle
    from .exceptions import (
        DriverError, AuthenticationError, ConnectionError,
        ObjectNotFoundError, FieldNotFoundError, QuerySyntaxError,
        RateLimitError, ValidationError, TimeoutError
    )
except ImportError:
    # Running as standalone script (e.g., in tests)
    from base import BaseDriver, DriverCapabilities, PaginationStyle
    from exceptions import (
        DriverError, AuthenticationError, ConnectionError,
        ObjectNotFoundError, FieldNotFoundError, QuerySyntaxError,
        RateLimitError, ValidationError, TimeoutError
    )


class FidooDriver(BaseDriver):
    """
    Fidoo Expense Management API Driver

    REST API driver for Fidoo platform integration.

    Features:
    - User management (CRUD)
    - Card operations (load, unload, query)
    - Transaction tracking (cards, cash, MVC)
    - Expense management
    - Travel and billing reports
    - Settings and configuration access

    Authentication:
    - API Key via X-Api-Key header
    - Generated by Main Administrator in Fidoo settings
    - Multiple keys supported with read/write permissions

    Pagination:
    - Offset token-based
    - Default limit: 100 records per request
    - Maximum limit: 100 records per request

    Rate Limiting:
    - 6,000 requests per customer per day
    - Automatic retry with exponential backoff on 429 errors
    - Check remaining: get_rate_limit_status()

    Example:
        >>> client = FidooDriver.from_env()
        >>> users = client.list_objects()
        >>> cards = client.read("card/get-cards", limit=10)
    """

    # Class-level constants
    _driver_name = "FidooDriver"
    _default_base_url = "https://api.fidoo.com/v2"
    _default_timeout = 30
    _default_max_retries = 3

    def __init__(
        self,
        base_url: Optional[str] = None,
        api_key: Optional[str] = None,
        access_token: Optional[str] = None,
        timeout: int = 30,
        max_retries: int = 3,
        debug: bool = False,
        **kwargs
    ):
        """
        Initialize FidooDriver.

        IMPORTANT: Initialization follows strict 4-phase order:
        1. Custom attributes
        2. Parent attributes (manually, DO NOT call super().__init__())
        3. Create session
        4. Validate connection

        Args:
            base_url: API base URL (default: https://api.fidoo.com/v2)
            api_key: API key for authentication
            access_token: OAuth access token (alternative to api_key)
            timeout: Request timeout in seconds (default: 30)
            max_retries: Max retry attempts for failed requests (default: 3)
            debug: Enable debug logging (default: False)
            **kwargs: Additional driver-specific options

        Raises:
            AuthenticationError: If credentials are invalid
            ConnectionError: If cannot reach API

        Example:
            >>> client = FidooDriver.from_env()
            >>> # Or explicit credentials:
            >>> client = FidooDriver(
            ...     api_key="your_api_key_here",
            ...     timeout=60
            ... )
        """

        # ===== PHASE 1: Set custom attributes =====
        self.driver_name = self._driver_name
        self.base_url_demo = "https://api-demo.fidoo.com/v2"

        # Setup logging
        if debug:
            logging.basicConfig(level=logging.DEBUG)
        self.logger = logging.getLogger(__name__)
        if debug:
            self.logger.setLevel(logging.DEBUG)
        else:
            self.logger.setLevel(logging.WARNING)

        # ===== PHASE 2: Set parent class attributes =====
        # DO NOT call super().__init__()! Set these manually.
        # This MUST happen BEFORE _create_session() so session can use them.
        self.base_url = base_url or self._default_base_url
        self.api_key = api_key
        self.access_token = access_token
        self.timeout = timeout or self._default_timeout
        self.max_retries = max_retries or self._default_max_retries
        self.debug = debug

        # ===== PHASE 3: Create session =====
        # Session creation can now use all attributes set above
        self.session = self._create_session()

        # ===== PHASE 4: Validate connection =====
        # Validation can now use self.session and other attributes
        self._validate_connection()

    @classmethod
    def from_env(cls, **kwargs) -> "FidooDriver":
        """
        Create FidooDriver instance from environment variables.

        Environment variables:
        - FIDOO_API_KEY: API key (required)
        - FIDOO_BASE_URL: API base URL (optional, defaults to production)
        - FIDOO_TIMEOUT: Request timeout in seconds (optional)
        - FIDOO_DEBUG: Enable debug logging (optional, "true"/"false")

        Args:
            **kwargs: Additional arguments passed to __init__

        Returns:
            Configured FidooDriver instance

        Raises:
            AuthenticationError: If required env vars are missing

        Example:
            >>> driver = FidooDriver.from_env()
            >>> # Requires FIDOO_API_KEY in environment
        """
        api_key = os.getenv("FIDOO_API_KEY")
        if not api_key:
            raise AuthenticationError(
                "Missing API key. Set FIDOO_API_KEY environment variable.",
                details={
                    "required_env_vars": ["FIDOO_API_KEY"],
                    "documentation": "https://www.fidoo.com/expense-management/integrace/api"
                }
            )

        base_url = os.getenv("FIDOO_BASE_URL")
        timeout = int(os.getenv("FIDOO_TIMEOUT", "30"))
        debug = os.getenv("FIDOO_DEBUG", "false").lower() == "true"

        return cls(
            api_key=api_key,
            base_url=base_url,
            timeout=timeout,
            debug=debug,
            **kwargs
        )

    def get_capabilities(self) -> DriverCapabilities:
        """
        Return driver capabilities.

        Returns:
            DriverCapabilities with supported features

        Example:
            >>> caps = client.get_capabilities()
            >>> if caps.write:
            ...     print("Write operations supported")
        """
        return DriverCapabilities(
            read=True,
            write=True,
            update=True,
            delete=True,
            batch_operations=True,
            streaming=False,
            pagination=PaginationStyle.OFFSET_TOKEN,
            query_language=None,
            max_page_size=100,
            supports_transactions=False,
            supports_relationships=True
        )

    # ===== Discovery Methods =====

    def list_objects(self) -> List[str]:
        """
        List available objects/endpoints in Fidoo API.

        Returns:
            List of object names

        Example:
            >>> objects = client.list_objects()
            >>> print(objects)
            ['user', 'card', 'transaction', 'expense', 'travel', ...]
        """
        return [
            "user",
            "card",
            "transaction",
            "cash-transaction",
            "mvc-transaction",
            "expense",
            "travel",
            "personal-billing",
            "settings"
        ]

    def get_fields(self, object_name: str) -> Dict[str, Any]:
        """
        Get field schema for an object.

        For Fidoo API, returns endpoint metadata and available parameters.

        Args:
            object_name: Name of the object (e.g., "card", "user", "expense")

        Returns:
            Dictionary with field/parameter definitions

        Raises:
            ObjectNotFoundError: If object doesn't exist

        Example:
            >>> fields = client.get_fields("card")
            >>> print(fields.keys())
        """
        schemas = {
            "user": {
                "endpoints": ["get-user", "get-users", "add-user", "activate-user", "deactivate-user"],
                "fields": {
                    "userId": {"type": "string", "required": False},
                    "firstName": {"type": "string", "required": False},
                    "lastName": {"type": "string", "required": False},
                    "email": {"type": "string", "required": False},
                    "active": {"type": "boolean", "required": False},
                    "employeeNumber": {"type": "string", "required": False}
                }
            },
            "card": {
                "endpoints": ["get-cards", "load-card", "unload-card", "load-status", "unload-status"],
                "fields": {
                    "userId": {"type": "string", "required": True},
                    "cardId": {"type": "string", "required": False},
                    "amount": {"type": "number", "required": False},
                    "limit": {"type": "integer", "required": False, "default": 100, "max": 100},
                    "offsetToken": {"type": "string", "required": False}
                }
            },
            "transaction": {
                "endpoints": ["get-card-transactions", "get-cash-transactions", "get-transactions"],
                "fields": {
                    "cardId": {"type": "string", "required": False},
                    "from": {"type": "string", "format": "ISO8601", "required": False},
                    "to": {"type": "string", "format": "ISO8601", "required": False},
                    "limit": {"type": "integer", "required": False, "default": 100, "max": 100},
                    "offsetToken": {"type": "string", "required": False}
                }
            },
            "expense": {
                "endpoints": ["get-expenses", "get-expense-items", "edit-expense"],
                "fields": {
                    "ownerId": {"type": "string", "required": False},
                    "from": {"type": "string", "format": "ISO8601", "required": False},
                    "to": {"type": "string", "format": "ISO8601", "required": False},
                    "closed": {"type": "boolean", "required": False},
                    "limit": {"type": "integer", "required": False, "default": 100, "max": 100},
                    "offsetToken": {"type": "string", "required": False}
                }
            },
            "travel": {
                "endpoints": ["get-travel-reports", "get-travel-requests"],
                "fields": {
                    "from": {"type": "string", "format": "ISO8601", "required": False},
                    "to": {"type": "string", "format": "ISO8601", "required": False},
                    "limit": {"type": "integer", "required": False, "default": 100, "max": 100},
                    "offsetToken": {"type": "string", "required": False}
                }
            },
            "settings": {
                "endpoints": ["get-cost-centers", "get-projects", "get-vehicles", "get-vat-breakdowns"],
                "fields": {
                    "limit": {"type": "integer", "required": False, "default": 100, "max": 100},
                    "offsetToken": {"type": "string", "required": False}
                }
            }
        }

        if object_name not in schemas:
            available = list(schemas.keys())
            raise ObjectNotFoundError(
                f"Object '{object_name}' not found. Available objects: {', '.join(available)}",
                details={
                    "requested": object_name,
                    "available": available
                }
            )

        return schemas[object_name]

    # ===== Read Operations =====

    def read(
        self,
        query: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        Execute a query and return results.

        For Fidoo API, query is the endpoint path (without /v2/ prefix).

        Args:
            query: Endpoint path (e.g., "user/get-users", "card/get-cards")
            limit: Maximum number of records (max: 100, default: 100)
            offset: Not used - Fidoo uses offsetToken for pagination

        Returns:
            List of records

        Raises:
            ConnectionError: If API is unreachable
            AuthenticationError: If credentials are invalid
            RateLimitError: If rate limit exceeded
            QuerySyntaxError: If query is invalid

        Example:
            >>> users = client.read("user/get-users", limit=50)
            >>> cards = client.read("card/get-cards")
            >>> transactions = client.read("transaction/get-card-transactions")
        """
        # Validate limit
        if limit is None:
            limit = 100
        if limit > 100:
            raise ValidationError(
                f"limit cannot exceed 100 (got: {limit})",
                details={
                    "provided": limit,
                    "maximum": 100,
                    "parameter": "limit"
                }
            )

        # Build endpoint URL
        endpoint = query if query.startswith("/") else f"/{query}"

        # Prepare request payload
        payload = {"limit": limit}
        if offset:
            payload["offsetToken"] = offset

        try:
            response = self._api_call(endpoint, method="POST", json=payload)
            return self._parse_response(response)
        except requests.HTTPError as e:
            self._handle_api_error(e.response, context=f"reading {query}")

    def read_batched(
        self,
        query: str,
        batch_size: int = 100
    ) -> Iterator[List[Dict[str, Any]]]:
        """
        Execute query and yield results in batches (memory-efficient).

        For large datasets, use this instead of read() to avoid loading all
        records into memory at once.

        Args:
            query: Endpoint path (e.g., "user/get-users")
            batch_size: Records per batch (max: 100)

        Yields:
            Batches of records as lists

        Raises:
            ValidationError: If batch_size exceeds 100

        Example:
            >>> for batch in client.read_batched("user/get-users", batch_size=100):
            ...     print(f"Processing {len(batch)} users...")
            ...     process_batch(batch)
        """
        if batch_size > 100:
            raise ValidationError(
                f"batch_size cannot exceed 100 (got: {batch_size})",
                details={"maximum": 100}
            )

        offset_token = None
        endpoint = query if query.startswith("/") else f"/{query}"

        while True:
            payload = {"limit": batch_size}
            if offset_token:
                payload["offsetToken"] = offset_token

            try:
                response = self._api_call(endpoint, method="POST", json=payload)
                response_data = response.json()
            except requests.HTTPError as e:
                self._handle_api_error(e.response, context=f"batch reading {query}")

            # Parse records
            records = self._parse_response(response)
            if records:
                yield records

            # Check if more records available
            if isinstance(response_data, dict):
                is_complete = response_data.get("complete", True)
                next_token = response_data.get("nextOffsetToken")

                if is_complete or not next_token:
                    break

                offset_token = next_token
            else:
                break

    def call_endpoint(
        self,
        endpoint: str,
        method: str = "POST",
        params: Optional[Dict[str, Any]] = None,
        data: Optional[Dict[str, Any]] = None,
        **kwargs
    ) -> Dict[str, Any]:
        """
        Call a REST API endpoint directly (low-level access).

        Args:
            endpoint: API endpoint path (e.g., "/v2/card/get-cards")
            method: HTTP method ("GET", "POST", "PUT", "DELETE")
            params: URL query parameters
            data: Request body (for POST/PUT)
            **kwargs: Additional request options

        Returns:
            Response data as dictionary

        Raises:
            ConnectionError: If API is unreachable
            RateLimitError: If rate limit exceeded

        Example:
            >>> result = client.call_endpoint(
            ...     "/v2/user/get-users",
            ...     method="GET",
            ...     params={"limit": 10}
            ... )
        """
        # Normalize endpoint
        if not endpoint.startswith("/"):
            endpoint = f"/{endpoint}"

        try:
            response = self._api_call(
                endpoint,
                method=method,
                params=params,
                json=data,
                **kwargs
            )
            return response.json()
        except requests.HTTPError as e:
            self._handle_api_error(e.response, context=f"calling {endpoint}")

    # ===== Write Operations =====

    def create(self, object_name: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create a new record.

        Not all objects support creation via API. Check get_capabilities()
        and documentation for write support.

        Args:
            object_name: Name of object (e.g., "user", "card")
            data: Field values as dictionary

        Returns:
            Created record with ID

        Raises:
            NotImplementedError: If object doesn't support creation
            ValidationError: If data is invalid
            ConnectionError: If API call fails

        Example:
            >>> new_user = client.create("user", {
            ...     "firstName": "John",
            ...     "lastName": "Doe",
            ...     "email": "john@example.com"
            ... })
        """
        # Map object names to API endpoints
        endpoint_map = {
            "user": "/user/add-user"
        }

        if object_name not in endpoint_map:
            raise NotImplementedError(
                f"Create operations not supported for '{object_name}'",
                details={"object": object_name}
            )

        endpoint = endpoint_map[object_name]

        try:
            response = self._api_call(endpoint, method="POST", json=data)
            response_data = response.json()

            # Check for errors
            if isinstance(response_data, dict) and response_data.get("error"):
                error = response_data["error"]
                raise ValidationError(
                    f"Creation failed: {error.get('message', 'Unknown error')}",
                    details={"error": error}
                )

            return response_data
        except requests.HTTPError as e:
            self._handle_api_error(e.response, context=f"creating {object_name}")

    def update(self, object_name: str, record_id: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Update an existing record.

        Args:
            object_name: Name of object
            record_id: ID of record to update
            data: Field values to update

        Returns:
            Updated record

        Raises:
            NotImplementedError: If updates not supported
            ObjectNotFoundError: If record doesn't exist
        """
        # Map object names to API endpoints
        endpoint_map = {
            "expense": "/expense/edit-expense"
        }

        if object_name not in endpoint_map:
            raise NotImplementedError(
                f"Update operations not supported for '{object_name}'",
                details={"object": object_name}
            )

        endpoint = endpoint_map[object_name]
        payload = {"expenseId": record_id, **data}

        try:
            response = self._api_call(endpoint, method="POST", json=payload)
            return response.json()
        except requests.HTTPError as e:
            self._handle_api_error(e.response, context=f"updating {object_name}")

    def delete(self, object_name: str, record_id: str) -> bool:
        """
        Delete a record.

        WARNING: Agents should RARELY generate delete operations!
        Always require explicit user approval before deleting.

        Args:
            object_name: Name of object
            record_id: ID of record to delete

        Returns:
            True if successful

        Raises:
            NotImplementedError: If deletes not supported
        """
        # Map object names to API endpoints
        endpoint_map = {
            "user": "/user/delete-user"
        }

        if object_name not in endpoint_map:
            raise NotImplementedError(
                f"Delete operations not supported for '{object_name}'",
                details={"object": object_name}
            )

        endpoint = endpoint_map[object_name]
        payload = {"userId": record_id}

        try:
            response = self._api_call(endpoint, method="POST", json=payload)
            response.raise_for_status()
            return True
        except requests.HTTPError as e:
            self._handle_api_error(e.response, context=f"deleting {object_name}")

    # ===== Utility Methods =====

    def get_rate_limit_status(self) -> Dict[str, Any]:
        """
        Get current rate limit status.

        Fidoo's rate limit: 6,000 requests per customer per day
        There is no public endpoint to check remaining quota.

        Returns:
            Dictionary with rate limit information

        Example:
            >>> status = client.get_rate_limit_status()
            >>> print(f"Daily limit: {status['limit']} requests")
        """
        return {
            "limit": 6000,
            "period": "per day",
            "remaining": None,  # Not provided by API
            "reset_at": None,
            "documentation": "https://www.fidoo.com/expense-management/integrace/api"
        }

    def close(self):
        """
        Close connections and cleanup resources.

        Example:
            >>> client = FidooDriver.from_env()
            >>> try:
            ...     data = client.read("user/get-users")
            ... finally:
            ...     client.close()
        """
        if hasattr(self, "session") and self.session:
            self.session.close()

    # ===== Internal Methods =====

    def _create_session(self) -> requests.Session:
        """
        Create HTTP session with authentication.

        Bug Prevention #1 & #2:
        - Use EXACT header names from docs (X-Api-Key)
        - Do NOT set Content-Type in session headers

        Returns:
            Configured requests.Session with auth headers
        """
        session = requests.Session()

        # Set headers that apply to ALL requests
        session.headers.update({
            "Accept": "application/json",
            "User-Agent": f"{self.driver_name}-Python-Driver/1.0.0",
        })
        # NOTE: Do NOT set Content-Type here! requests handles it automatically

        # Add authentication (use IF not ELIF - multiple can coexist)
        if self.access_token:
            session.headers["Authorization"] = f"Bearer {self.access_token}"

        if self.api_key:
            # BUG PREVENTION #1: EXACT header name from docs
            session.headers["X-Api-Key"] = self.api_key

        # Configure retries (automatic exponential backoff on rate limits)
        if self.max_retries > 0:
            retry_strategy = Retry(
                total=self.max_retries,
                backoff_factor=1,
                status_forcelist=[429, 500, 502, 503, 504],
                allowed_methods=["GET", "POST", "PUT", "DELETE"]
            )
            adapter = HTTPAdapter(max_retries=retry_strategy)
            session.mount("https://", adapter)
            session.mount("http://", adapter)

        return session

    def _api_call(
        self,
        endpoint: str,
        method: str = "POST",
        params: Optional[Dict[str, Any]] = None,
        json: Optional[Dict[str, Any]] = None,
        **kwargs
    ) -> requests.Response:
        """
        Make API call with automatic retry on rate limits.

        Args:
            endpoint: API endpoint path
            method: HTTP method
            params: URL query parameters
            json: JSON body payload
            **kwargs: Additional request options

        Returns:
            Response object

        Raises:
            RateLimitError: If rate limit exceeded after retries
            ConnectionError: If connection fails
            TimeoutError: If request times out
        """
        url = urljoin(self.base_url, endpoint.lstrip("/"))

        for attempt in range(self.max_retries + 1):
            try:
                if self.debug:
                    self.logger.debug(f"[{method}] {url}")
                    if json:
                        self.logger.debug(f"  Payload: {json}")

                response = self.session.request(
                    method,
                    url,
                    params=params,
                    json=json,
                    timeout=self.timeout,
                    **kwargs
                )

                response.raise_for_status()
                return response

            except requests.exceptions.Timeout:
                raise TimeoutError(
                    f"Request timed out after {self.timeout} seconds",
                    details={"timeout": self.timeout, "url": url}
                )

            except requests.exceptions.ConnectionError as e:
                raise ConnectionError(
                    f"Cannot connect to Fidoo API: {e}",
                    details={"url": url, "error": str(e)}
                )

            except requests.HTTPError as e:
                if e.response.status_code == 429:
                    # Rate limited - retry with exponential backoff
                    retry_after = int(e.response.headers.get("Retry-After", 2 ** attempt))

                    if attempt < self.max_retries:
                        if self.debug:
                            self.logger.debug(
                                f"Rate limited. Retrying in {retry_after}s (attempt {attempt + 1}/{self.max_retries})"
                            )
                        time.sleep(retry_after)
                        continue
                    else:
                        raise RateLimitError(
                            f"API rate limit exceeded after {self.max_retries} attempts. Retry after {retry_after} seconds.",
                            details={
                                "retry_after": retry_after,
                                "attempts": self.max_retries,
                                "limit": 6000,
                                "period": "per day"
                            }
                        )

                # Other HTTP errors - don't retry
                raise

    def _parse_response(self, response: requests.Response) -> List[Dict[str, Any]]:
        """
        Parse API response and extract data records.

        Bug Prevention #3: Case-sensitive field fallbacks
        Tries common field name variations until one works.

        Args:
            response: HTTP response from API

        Returns:
            List of records
        """
        try:
            data = response.json()
        except ValueError as e:
            raise ConnectionError(
                "Invalid JSON response from API",
                details={
                    "status_code": response.status_code,
                    "content": response.text[:500],
                    "error": str(e)
                }
            )

        # Handle direct array responses
        if isinstance(data, list):
            return data

        # Handle object-wrapped responses
        if isinstance(data, dict):
            # Fidoo API uses *List naming convention (userList, cardList, etc.)
            # Check for any key ending in 'List' first
            records = None
            for key in data.keys():
                if key.endswith('List') and isinstance(data[key], list):
                    records = data[key]
                    break

            # Fallback to common field names
            if records is None:
                records = (
                    data.get("data") or
                    data.get("items") or
                    data.get("results") or
                    data.get("records") or
                    data.get("Items") or
                    data.get("Data") or
                    data.get("Results") or
                    data.get("Records") or
                    []
                )

            # Ensure we return a list
            if isinstance(records, list):
                return records
            elif records is not None:
                return [records]  # Wrap single object in list
            else:
                return []

        # Unknown format
        return []

    def _handle_api_error(self, response: requests.Response, context: str = ""):
        """
        Convert HTTP errors to structured driver exceptions.

        Args:
            response: Failed HTTP response
            context: Context string (e.g., "reading users")

        Raises:
            Appropriate DriverError subclass
        """
        status_code = response.status_code

        try:
            error_data = response.json()
            if isinstance(error_data, dict) and error_data.get("error"):
                error = error_data["error"]
                error_msg = error.get("message", error.get("code", "Unknown error"))
            else:
                error_msg = error_data.get("message", "Unknown error")
        except ValueError:
            error_msg = response.text[:500]

        # Map status codes to exceptions
        if status_code == 401:
            raise AuthenticationError(
                f"Authentication failed: {error_msg}",
                details={
                    "status_code": 401,
                    "context": context,
                    "api_response": error_msg
                }
            )

        elif status_code == 403:
            raise AuthenticationError(
                f"Permission denied: {error_msg}",
                details={
                    "status_code": 403,
                    "context": context,
                    "api_response": error_msg
                }
            )

        elif status_code == 404:
            raise ObjectNotFoundError(
                f"Resource not found: {error_msg}",
                details={
                    "status_code": 404,
                    "context": context,
                    "api_response": error_msg
                }
            )

        elif status_code == 429:
            retry_after = response.headers.get("Retry-After", "60")
            raise RateLimitError(
                f"Rate limit exceeded: {error_msg}",
                details={
                    "status_code": 429,
                    "retry_after": retry_after,
                    "context": context,
                    "api_response": error_msg
                }
            )

        elif status_code >= 500:
            raise ConnectionError(
                f"API server error: {error_msg}",
                details={
                    "status_code": status_code,
                    "context": context,
                    "api_response": error_msg
                }
            )

        else:
            raise DriverError(
                f"API request failed: {error_msg}",
                details={
                    "status_code": status_code,
                    "context": context,
                    "api_response": error_msg
                }
            )

    def _validate_connection(self):
        """
        Validate connection at initialization (fail fast!).

        Raises:
            AuthenticationError: If credentials are invalid
            ConnectionError: If cannot reach API
        """
        if not self.api_key and not self.access_token:
            raise AuthenticationError(
                "No authentication provided. Set api_key or access_token.",
                details={
                    "solution": "Use FidooDriver.from_env() or pass api_key to constructor"
                }
            )

        try:
            # Verify API key with status endpoint
            response = self.session.get(
                urljoin(self.base_url, "status/user-info"),
                timeout=self.timeout
            )
            response.raise_for_status()

            if self.debug:
                self.logger.debug("Connection validated successfully")

        except requests.HTTPError as e:
            if e.response.status_code == 401:
                raise AuthenticationError(
                    "Invalid API key. Check your credentials.",
                    details={
                        "status_code": 401,
                        "api_url": self.base_url
                    }
                )
            else:
                raise ConnectionError(
                    f"Cannot validate connection to Fidoo API: {e}",
                    details={"status_code": e.response.status_code}
                )

        except requests.exceptions.RequestException as e:
            raise ConnectionError(
                f"Cannot reach Fidoo API at {self.base_url}: {e}",
                details={"api_url": self.base_url, "error": str(e)}
            )
